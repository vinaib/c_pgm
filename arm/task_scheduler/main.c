/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

/*
 * 1) Create 4 tasks, where each task has its own stack
 * 2) Schedule it in round robin by carrying out the context switching
 * 3) Round robin scheduling: Time slices are assigned to each task in equal portions and in circular order
 * 4) Use PSP for thread mode stack
 * 5) Use MSP for Handler mode stack
 * 6) First use systick handler to carry out the context switch operation between multiple tasks
 * 7) later change to pendSV handler
 * 8) During context switch, scheduler saves the context(state) of the task in task's private stack.
 * 9) Task: A piece of code or function is called a task when it is schedulable and never loses its state, unless it is deleted permanently.
 *
 * Scheduling policy selection:
 * 1) We will be using round robin "preemptive" scheduling. Switching out TaskN and Switching In TaskN+1 for every 1ms
 * 2) No task priority
 * 3) we will use SysTick timer to generate exception for every 1ms to run the scheduler code
 *
 * What is scheduling?
 * Scheduling is an algorithm which takes the decision of preempting a running task from the CPU and takes the decision about which
 * task should run on the CPU next.
 * The decision could be based on many factors such as system load, the priority of tasks, shared resource access, or a simple
 * round-robin method.
 *
 * What is context switching?
 * Context switching is the procedure of switching out of the currently running task from the CPU after saving the task's execution context
 * or state and switching in the next task's to run on the CPU by retrieving the past execution context or state of the task.
 *
 * What is state of task?
 * collection of Processor's: GPR + Status Register + Special Registers
 * GPR: R0 - R12
 * PC: While Processor preempts current task, PC holds the next instruction to be executed. So preserving of PC is important when preempted
 * task is scheduled again. As Preemption is done in systick/pendsv exception handler, which is not a function call, LR cannot be used here.
 * LR:
 * PSP: current state of stack pointer
 * PSR: snapshot of current state
 * Not required these Special Registers: PRIMASK, FAULTMASK, BASEPRI, CONTROL: not required. These are privileged registers.
 *
 * Sharing global variables between handler and thread mode code:
 * Disable interrupt while accessing global variable
 */

#include<stdio.h>
#include<stdint.h>
#include<main.h>

TCB_t	user_tasks[MAX_TASKS];

uint8_t current = 1;	//task1 running
uint32_t g_tick_count = 0;

const uint32_t const_v_1 = 100;
const uint32_t const_v_2 = 100;

void schedule(void)
{
	uint32_t *pICSR = (uint32_t *)0xE000ED04;

	//pend the pendSV exception
	*pICSR |= (1<<28);
}

void task_delay(uint32_t tick_count)
{
	INTERRUPT_DISABLE();

	if(current != 0) {
		user_tasks[current].block_count = g_tick_count + tick_count;
		user_tasks[current].current_state = TASK_BLOCKED_STATE;
		/*once task moved to blocked state, schedule the other task*/
		schedule();
	}

	INTERRUPT_ENABLE();
}


int main(void)
{
	//printf("task scheduler\n");

	enable_processor_faults();

	init_scheduler_stack(SCHED_STACK_START);

	init_tasks_stack();

	init_systick_timer(TICK_HZ);

	// till here stack used is msp, before launching user tasks switch to psp
	switch_stack_from_msp_to_psp();

	task1_handler();

	for(;;);
}

void idle_task(void)
{
	//printf("idle task\n");
	while(1);
}

void task1_handler(void)
{
	while(1) {
		//printf("This is Task1\n");
		task_delay(1000);
	}
}

void task2_handler(void)
{
	while(1) {
		//printf("This is Task2\n");
		task_delay(2000);
	}

}

void task3_handler(void)
{
	while(1) {
		//printf("This is Task3\n");
		task_delay(3000);
	}

}

void task4_handler(void)
{
	while(1) {
		//printf("This is Task4\n");
		task_delay(4000);
	}

}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t *pSRVR = (uint32_t*)0xE000E014;
	uint32_t *pSCSR = (uint32_t*)0xE000E010;

	uint32_t count_value = (SYSTICK_TIM_CLK/tick_hz) - 1; //-1 as per RM

	//clear the value of SVR
	*pSRVR &= ~(0x00FFFFFF);

	/* load the value in to SVR */
	*pSRVR |= count_value;

	//do some settings
	*pSCSR |= (1 << 1); //enable systick exception request
	*pSCSR |= (1 << 2);  //indicate the clock source as processor

	//enable systick
	*pSCSR |= (1 << 0); //enables the counter
}

__attribute__((naked)) void init_scheduler_stack(uint32_t sched_top_of_stack)
{
	__asm volatile("MSR MSP,%0": :"r"(sched_top_of_stack):);
	__asm volatile("bx lr");
}


void init_tasks_stack(void)
{
	uint32_t *pPSP;

	user_tasks[0].current_state = TASK_READY_STATE;	//idle tasks
	user_tasks[1].current_state = TASK_READY_STATE;
	user_tasks[2].current_state = TASK_READY_STATE;
	user_tasks[3].current_state = TASK_READY_STATE;
	user_tasks[4].current_state = TASK_READY_STATE;

	user_tasks[0].psp_value = IDLE_STACK_START;
	user_tasks[1].psp_value = T1_STACK_START;
	user_tasks[2].psp_value = T2_STACK_START;
	user_tasks[3].psp_value = T3_STACK_START;
	user_tasks[4].psp_value = T4_STACK_START;

	user_tasks[0].task_handler = idle_task;
	user_tasks[1].task_handler = task1_handler;
	user_tasks[2].task_handler = task2_handler;
	user_tasks[3].task_handler = task3_handler;
	user_tasks[4].task_handler = task4_handler;

	for (int i=0; i<MAX_TASKS; i++) {

		pPSP = (uint32_t*)user_tasks[i].psp_value;

		pPSP--;
		*pPSP = DUMMY_XPSR;	//0x01000000

		pPSP--; //PC
		*pPSP = (uint32_t)user_tasks[i].task_handler;

		pPSP--;	//LR
		*pPSP= 0xFFFFFFFD;

		//GPR
		for(int j=0;j<13;j++) {
			pPSP--;
			*pPSP=0;
		}

		//strore pPSP value in global
		user_tasks[i].psp_value = (uint32_t)pPSP;

	}

}

uint32_t get_psp_value(void)
{
	return user_tasks[current].psp_value;
}

void save_psp_value(uint32_t current_psp_value)
{
	user_tasks[current].psp_value = current_psp_value;
}

void update_next_task(void)
{
	int state = TASK_BLOCKED_STATE;

	for(int i=0; i<MAX_TASKS; i++) {

		current++;
		current %= MAX_TASKS;
		state = user_tasks[current].current_state;
		if((state == TASK_READY_STATE) && (current!=0))
			break;
	}

	if(state != TASK_READY_STATE)
		current= 0;
}

__attribute__((naked)) void switch_stack_from_msp_to_psp(void)
{
	//1. initialize the PSP with TASK1 stack start address

	//get the value of PSP of current task. This function is naked, to avoid
	//SP, LR getting corrupted, but when you branch to c function from naked function
	//again the LR may get corrupted, so preserve LR on to stack and after calling
	//c function pop LR contents
	__asm volatile("push {LR}");	//preserve LR which connects back to main
	__asm volatile("BL get_psp_value");
	__asm volatile("msr psp,r0");	//initialize psp
	__asm volatile("pop {LR}");	//pops back LR

	//2. change SP to PSP using CONTROL register
	__asm volatile("mov r0, #0x02");
	__asm volatile("msr control, r0");

	//go back to main
	__asm volatile("bx lr");
}

void enable_processor_faults(void)
{
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	*pSHCSR |= (1 << 16); //mem manage
	*pSHCSR |= (1 << 17); //bus fault
	*pSHCSR |= (1 << 18); //usage fault
}

/*
 * SF1 = xPSR, PC, LR, R12, R3, R2, R1, R0 this is done automatically by processor
 * SF2 = SP[PSP], {R11 - R4} handled in systick handler
 */
__attribute__ ((naked)) void PendSV_Handler(void)
{
	/*
	 * Save the context of current task
	 * 1. Get current running task's PSP value
	 * 2. Using that PSP value store SF2(R4 to R11)
	 * 3. Save the current value of PSP
	 */

	/* we cannot use push instructions, as handler uses msp and contents will
	 * be pushed to msp stack not to task1 psp stack.
	 */
	__asm volatile("mrs r0, psp");

	/* stmdb, decrement before each register access.
	 * "!" denotes r0 to get updated
	 * */
	__asm volatile("stmdb r0!,{r4-r11}");

	__asm volatile("push {lr}");

	__asm volatile("bl save_psp_value");

	/*
	 * Retrieve the context of current task
	 * 1. Decide next task to run
	 * 2. Get its past PSP value
	 * 3. Using that PSP value retrieve SF2(R4 to R11)
	 * 4. Update PSP and exit
	 */
	__asm volatile("bl update_next_task");

	__asm volatile("BL get_psp_value");

	__asm volatile("ldmia r0!,{r4-r11}");

	__asm volatile("msr psp, r0");

	__asm volatile("pop {lr}");

	__asm volatile("bx lr");
}

void update_global_tick_count(void)
{
	g_tick_count++;
}

void unblock_tasks(void)
{
	/* skip idle task, so start loop from 1*/
	for(int i=1; i<MAX_TASKS; i++)
	{
		if(user_tasks[i].current_state != TASK_READY_STATE) {
			if(user_tasks[i].block_count == g_tick_count) {
				user_tasks[i].current_state = TASK_READY_STATE;
			}
		}
	}
}

void SysTick_Handler(void)
{
	uint32_t *pICSR = (uint32_t *)0xE000ED04;

	update_global_tick_count();

	unblock_tasks();

	//pend the pendSV exception
	*pICSR |= (1<<28);
}

void HardFault_Handler(void)
{
	//printf("Exception: HardFault_Handler\n");
	while(1);
}

void MemManage_Handler(void)
{
	//printf("Exception: MemManage_Handler\n");
	while(1);
}

void BusFault_Handler(void)
{
	//printf("Exception: BusFault_Handler\n");
	while(1);
}
